{"ast":null,"code":"const $points = {};\n\nfunction Dijkstra(grid) {\n  console.log(grid);\n  const nodes = getNodes(grid);\n  console.log(nodes);\n  console.log($points);\n  const nodeNeighbors = getNeighbors(grid, $points.startNode);\n\n  while ($points.endNode !== Infinity) {}\n\n  console.log(nodeNeighbors);\n} //function to get neighbors by node\n\n\nfunction getNeighbors(grid, node) {\n  console.log(node);\n  var nodeNeighbors = {};\n\n  if (node !== undefined || null) {\n    console.log(node.col);\n    nodeNeighbors.nodeRight = grid[node.row][node.col + 1];\n    nodeNeighbors.nodeLeft = grid[node.row][node.col - 1];\n    nodeNeighbors.nodeUp = grid[node.row - 1][node.col];\n    nodeNeighbors.nodeDown = grid[node.row + 1][node.col];\n  }\n\n  return nodeNeighbors;\n} // a visited node will never be checked again\n// function to update nodes to visited\n\n\nfunction updateToVisited(node, grid) {} //function to sort shortest nodes \n\n/*\nfunction sortShortest(grid) {\n\n}\n*/\n\n\nfunction getPoints(node) {\n  if (node.startNode) {\n    $points.startNode = node;\n  } else if (node.endNode) {\n    $points.endNode = node;\n  }\n\n  return $points;\n}\n\nfunction getNodes(grid) {\n  const nodes = [];\n\n  for (let row of grid) {\n    const currRow = [];\n\n    for (var node of row) {\n      if (node.startNode) {\n        node.nodeDistance = 0;\n        $points.startNode = node;\n      } else if (node.endNode) {\n        $points.endNode = node;\n      }\n\n      currRow.push(node);\n    }\n\n    nodes.push(currRow);\n  }\n\n  console.log($points);\n  return nodes;\n}\n\nexport default Dijkstra;","map":{"version":3,"sources":["/Users/sm00th-swagger/fun/pathfinderjs/src/dijkstras.js"],"names":["$points","Dijkstra","grid","console","log","nodes","getNodes","nodeNeighbors","getNeighbors","startNode","endNode","Infinity","node","undefined","col","nodeRight","row","nodeLeft","nodeUp","nodeDown","updateToVisited","getPoints","currRow","nodeDistance","push"],"mappings":"AACA,MAAMA,OAAO,GAAG,EAAhB;;AAEA,SAASC,QAAT,CAAkBC,IAAlB,EAAwB;AACpBC,EAAAA,OAAO,CAACC,GAAR,CAAYF,IAAZ;AACA,QAAMG,KAAK,GAAGC,QAAQ,CAACJ,IAAD,CAAtB;AACAC,EAAAA,OAAO,CAACC,GAAR,CAAYC,KAAZ;AACAF,EAAAA,OAAO,CAACC,GAAR,CAAYJ,OAAZ;AACA,QAAMO,aAAa,GAAGC,YAAY,CAACN,IAAD,EAAOF,OAAO,CAACS,SAAf,CAAlC;;AACA,SAAOT,OAAO,CAACU,OAAR,KAAoBC,QAA3B,EAAqC,CAEpC;;AACDR,EAAAA,OAAO,CAACC,GAAR,CAAYG,aAAZ;AACH,C,CAED;;;AACA,SAASC,YAAT,CAAsBN,IAAtB,EAA4BU,IAA5B,EAAkC;AAC9BT,EAAAA,OAAO,CAACC,GAAR,CAAYQ,IAAZ;AACA,MAAIL,aAAa,GAAG,EAApB;;AACA,MAAGK,IAAI,KAAKC,SAAT,IAAsB,IAAzB,EAA+B;AAC3BV,IAAAA,OAAO,CAACC,GAAR,CAAYQ,IAAI,CAACE,GAAjB;AACAP,IAAAA,aAAa,CAACQ,SAAd,GAA0Bb,IAAI,CAACU,IAAI,CAACI,GAAN,CAAJ,CAAeJ,IAAI,CAACE,GAAL,GAAS,CAAxB,CAA1B;AACAP,IAAAA,aAAa,CAACU,QAAd,GAAyBf,IAAI,CAACU,IAAI,CAACI,GAAN,CAAJ,CAAeJ,IAAI,CAACE,GAAL,GAAS,CAAxB,CAAzB;AACAP,IAAAA,aAAa,CAACW,MAAd,GAAuBhB,IAAI,CAACU,IAAI,CAACI,GAAL,GAAS,CAAV,CAAJ,CAAiBJ,IAAI,CAACE,GAAtB,CAAvB;AACAP,IAAAA,aAAa,CAACY,QAAd,GAAyBjB,IAAI,CAACU,IAAI,CAACI,GAAL,GAAS,CAAV,CAAJ,CAAiBJ,IAAI,CAACE,GAAtB,CAAzB;AAEH;;AACD,SAAOP,aAAP;AACH,C,CAGA;AACA;;;AACD,SAASa,eAAT,CAAyBR,IAAzB,EAA+BV,IAA/B,EAAqC,CAEpC,C,CAED;;AACA;;;;;;;AAMA,SAASmB,SAAT,CAAmBT,IAAnB,EAAyB;AACrB,MAAGA,IAAI,CAACH,SAAR,EAAmB;AACfT,IAAAA,OAAO,CAACS,SAAR,GAAoBG,IAApB;AACH,GAFD,MAGK,IAAGA,IAAI,CAACF,OAAR,EAAiB;AAClBV,IAAAA,OAAO,CAACU,OAAR,GAAkBE,IAAlB;AACH;;AACD,SAAOZ,OAAP;AACH;;AAED,SAASM,QAAT,CAAkBJ,IAAlB,EAAwB;AACpB,QAAMG,KAAK,GAAG,EAAd;;AACA,OAAK,IAAIW,GAAT,IAAgBd,IAAhB,EAAsB;AAClB,UAAMoB,OAAO,GAAG,EAAhB;;AACA,SAAI,IAAIV,IAAR,IAAgBI,GAAhB,EAAqB;AACjB,UAAGJ,IAAI,CAACH,SAAR,EAAmB;AACfG,QAAAA,IAAI,CAACW,YAAL,GAAoB,CAApB;AACAvB,QAAAA,OAAO,CAACS,SAAR,GAAoBG,IAApB;AACH,OAHD,MAIK,IAAGA,IAAI,CAACF,OAAR,EAAiB;AAClBV,QAAAA,OAAO,CAACU,OAAR,GAAkBE,IAAlB;AACH;;AACDU,MAAAA,OAAO,CAACE,IAAR,CAAaZ,IAAb;AACH;;AACDP,IAAAA,KAAK,CAACmB,IAAN,CAAWF,OAAX;AACH;;AACDnB,EAAAA,OAAO,CAACC,GAAR,CAAYJ,OAAZ;AACA,SAAOK,KAAP;AACH;;AAED,eAAeJ,QAAf","sourcesContent":["\nconst $points = {}\n\nfunction Dijkstra(grid) {\n    console.log(grid)\n    const nodes = getNodes(grid)\n    console.log(nodes)\n    console.log($points)\n    const nodeNeighbors = getNeighbors(grid, $points.startNode)\n    while ($points.endNode !== Infinity) { \n\n    }\n    console.log(nodeNeighbors)\n}\n\n//function to get neighbors by node\nfunction getNeighbors(grid, node) {\n    console.log(node)\n    var nodeNeighbors = {}\n    if(node !== undefined || null) {\n        console.log(node.col)\n        nodeNeighbors.nodeRight = grid[node.row][node.col+1]\n        nodeNeighbors.nodeLeft = grid[node.row][node.col-1]\n        nodeNeighbors.nodeUp = grid[node.row-1][node.col]\n        nodeNeighbors.nodeDown = grid[node.row+1][node.col]\n\n    }\n    return nodeNeighbors\n}\n\n  \n // a visited node will never be checked again\n // function to update nodes to visited\nfunction updateToVisited(node, grid) {\n\n}\n\n//function to sort shortest nodes \n/*\nfunction sortShortest(grid) {\n\n}\n*/\n\nfunction getPoints(node) {\n    if(node.startNode) {\n        $points.startNode = node\n    }\n    else if(node.endNode) {\n        $points.endNode = node\n    }\n    return $points\n}\n\nfunction getNodes(grid) {\n    const nodes = []\n    for (let row of grid) {\n        const currRow = []\n        for(var node of row) {\n            if(node.startNode) {\n                node.nodeDistance = 0\n                $points.startNode = node\n            }\n            else if(node.endNode) {\n                $points.endNode = node\n            }\n            currRow.push(node)\n        }\n        nodes.push(currRow)\n    }\n    console.log($points)\n    return nodes \n}\n\nexport default Dijkstra"]},"metadata":{},"sourceType":"module"}