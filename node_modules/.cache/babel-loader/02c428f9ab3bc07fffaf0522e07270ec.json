{"ast":null,"code":"const $points = {};\n\nfunction Dijkstra(grid) {\n  const nodeNeighbors = getNeighbors(grid, $points.startNode);\n  const nodes = getNodes(grid);\n  console.log(nodeNeighbors);\n  console.log(nodes);\n  var distanceCounter = 0;\n\n  if (Object.keys($points).length > 0) {\n    while (distanceCounter < 10) {\n      var neighbors0 = getNeighbors(grid, grid[$points.startNode.row][$points.startNode.col + distanceCounter]);\n      Object.entries(neighbors0).map((node, nodeIdx) => {\n        grid[node[1].col][node[1].row] = node[1];\n        grid[node[1].col][node[1].row].nodeDistance = distanceCounter;\n      }); //const neighbors1 = getNeighbors(grid[$points.startNode.row][$points.startNode.col - distanceCounter])\n      //const neighbors2 = getNeighbors(grid[$points.startNode.row + distanceCounter][$points.startNode.col])\n      //const neighbors3 = getNeighbors(grid[$points.startNode.row - distanceCounter][$points.startNode.col])\n\n      distanceCounter += 1;\n    }\n  }\n} //function to get neighbors by node\n\n\nfunction getNeighbors(grid, node) {\n  console.log(node);\n  var nodeNeighbors = {};\n\n  if (node !== undefined || null) {\n    console.log(node.col);\n    nodeNeighbors.nodeRight = grid[node.row][node.col + 1];\n    nodeNeighbors.nodeRight.isVisited = true;\n    nodeNeighbors.nodeLeft = grid[node.row][node.col - 1];\n    nodeNeighbors.nodeLeft.isVisited = true;\n    nodeNeighbors.nodeUp = grid[node.row - 1][node.col];\n    nodeNeighbors.nodeUp.isVisited = true;\n    nodeNeighbors.nodeDown = grid[node.row + 1][node.col];\n    nodeNeighbors.nodeDown.isVisited = true;\n  }\n\n  return nodeNeighbors;\n} // a visited node will never be checked again\n// function to update nodes to visited\n//function to sort shortest nodes \n\n/*\nfunction sortShortest(grid) {\n\n}\n*/\n\n\nfunction getPoints(node) {\n  if (node.startNode) {\n    $points.startNode = node;\n  } else if (node.endNode) {\n    $points.endNode = node;\n  }\n\n  return $points;\n}\n\nfunction getNodes(grid) {\n  const nodes = [];\n\n  for (let row of grid) {\n    const currRow = [];\n\n    for (var node of row) {\n      if (node.startNode) {\n        node.nodeDistance = 0;\n        $points.startNode = node;\n      } else if (node.endNode) {\n        $points.endNode = node;\n      }\n\n      currRow.push(node);\n    }\n\n    nodes.push(currRow);\n  }\n\n  console.log($points);\n  return nodes;\n}\n\nexport default Dijkstra;","map":{"version":3,"sources":["/Users/sm00th-swagger/fun/pathfinderjs/src/dijkstras.js"],"names":["$points","Dijkstra","grid","nodeNeighbors","getNeighbors","startNode","nodes","getNodes","console","log","distanceCounter","Object","keys","length","neighbors0","row","col","entries","map","node","nodeIdx","nodeDistance","undefined","nodeRight","isVisited","nodeLeft","nodeUp","nodeDown","getPoints","endNode","currRow","push"],"mappings":"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","sourcesContent":["\nconst $points = {}\n\nfunction Dijkstra(grid) {\n    const nodeNeighbors = getNeighbors(grid, $points.startNode)\n    const nodes = getNodes(grid)\n    console.log(nodeNeighbors)\n    console.log(nodes) \n    var distanceCounter = 0\n    if(Object.keys($points).length > 0) {\n        while(distanceCounter < 10) {\n            var neighbors0 = getNeighbors(grid, grid[$points.startNode.row][$points.startNode.col + distanceCounter])\n            Object.entries(neighbors0).map((node, nodeIdx) => {\n                grid[node[1].col][node[1].row] = node[1]\n                grid[node[1].col][node[1].row].nodeDistance = distanceCounter\n            })\n        //const neighbors1 = getNeighbors(grid[$points.startNode.row][$points.startNode.col - distanceCounter])\n        //const neighbors2 = getNeighbors(grid[$points.startNode.row + distanceCounter][$points.startNode.col])\n        //const neighbors3 = getNeighbors(grid[$points.startNode.row - distanceCounter][$points.startNode.col])\n            distanceCounter +=1\n        }\n    } \n}\n\n\n//function to get neighbors by node\nfunction getNeighbors(grid, node) {\n    console.log(node)\n    var nodeNeighbors = {}\n    if(node !== undefined || null) {\n        console.log(node.col)\n        nodeNeighbors.nodeRight = grid[node.row][node.col+1]\n        nodeNeighbors.nodeRight.isVisited = true\n        nodeNeighbors.nodeLeft = grid[node.row][node.col-1]\n        nodeNeighbors.nodeLeft.isVisited = true\n        nodeNeighbors.nodeUp = grid[node.row-1][node.col]\n        nodeNeighbors.nodeUp.isVisited = true\n        nodeNeighbors.nodeDown = grid[node.row+1][node.col]\n        nodeNeighbors.nodeDown.isVisited = true\n\n    }\n    return nodeNeighbors\n}\n\n  \n // a visited node will never be checked again\n // function to update nodes to visited\n\n//function to sort shortest nodes \n/*\nfunction sortShortest(grid) {\n\n}\n*/\n\nfunction getPoints(node) {\n    if(node.startNode) {\n        $points.startNode = node\n    }\n    else if(node.endNode) {\n        $points.endNode = node\n    }\n    return $points\n}\n\nfunction getNodes(grid) {\n    const nodes = []\n    for (let row of grid) {\n        const currRow = []\n        for(var node of row) {\n            if(node.startNode) {\n                node.nodeDistance = 0\n                $points.startNode = node\n            }\n            else if(node.endNode) {\n                $points.endNode = node\n            }\n            currRow.push(node)\n        }\n        nodes.push(currRow)\n    }\n    console.log($points)\n    return nodes \n}\n\nexport default Dijkstra"]},"metadata":{},"sourceType":"module"}