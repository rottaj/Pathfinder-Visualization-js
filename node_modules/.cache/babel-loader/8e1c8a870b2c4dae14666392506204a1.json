{"ast":null,"code":"const $points = {};\n\nfunction Dijkstra(grid) {\n  const nodes = getNodes(grid);\n  var sctNodes = [];\n  var distanceCounter = 0;\n\n  if (Object.keys($points).length > 0) {\n    var startNeighbors = getNeighbors(grid, grid[$points.startNode.row][$points.startNode.col]);\n    sctNodes.push(startNeighbors);\n    Object.entries(sctNodes).forEach(neighbors => {\n      console.log(neighbors);\n      neighbors[1].forEach(node => {\n        var nodeNeighbors = getNeighbors(grid, node);\n        sctNodes.push(nodeNeighbors);\n      });\n    });\n  }\n\n  console.log(sctNodes);\n} //function to get neighbors by node\n\n\nfunction getNeighbors(grid, node) {\n  var nodeNeighbors = [];\n\n  if (node !== undefined || null) {\n    nodeNeighbors.push(grid[node.row][node.col + 1]); //nodeNeighbors.nodeRight.isVisited = true\n\n    nodeNeighbors.push(grid[node.row][node.col - 1]); //nodeNeighbors.nodeLeft.isVisited = true\n\n    nodeNeighbors.push(grid[node.row - 1][node.col]); //nodeNeighbors.nodeUp.isVisited = true\n\n    nodeNeighbors.push(grid[node.row + 1][node.col]); //nodeNeighbors.nodeDown.isVisited = true\n  }\n\n  return nodeNeighbors;\n} // a visited node will never be checked again\n// function to update nodes to visited\n//function to sort shortest nodes \n\n/*\nfunction sortShortest(grid) {\n\n}\n*/\n\n\nfunction getPoints(node) {\n  if (node.startNode) {\n    $points.startNode = node;\n  } else if (node.endNode) {\n    $points.endNode = node;\n  }\n\n  return $points;\n}\n\nfunction getNodes(grid) {\n  const nodes = [];\n\n  for (let row of grid) {\n    const currRow = [];\n\n    for (var node of row) {\n      if (node.startNode) {\n        node.nodeDistance = 0;\n        $points.startNode = node;\n      } else if (node.endNode) {\n        $points.endNode = node;\n      }\n\n      currRow.push(node);\n    }\n\n    nodes.push(currRow);\n  }\n\n  console.log($points);\n  return nodes;\n}\n\nexport default Dijkstra;","map":{"version":3,"sources":["/Users/sm00th-swagger/fun/pathfinderjs/src/dijkstras.js"],"names":["$points","Dijkstra","grid","nodes","getNodes","sctNodes","distanceCounter","Object","keys","length","startNeighbors","getNeighbors","startNode","row","col","push","entries","forEach","neighbors","console","log","node","nodeNeighbors","undefined","getPoints","endNode","currRow","nodeDistance"],"mappings":"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","sourcesContent":["\nconst $points = {}\n\nfunction Dijkstra(grid) {\n    const nodes = getNodes(grid)\n    var sctNodes = []\n    var distanceCounter = 0\n    if(Object.keys($points).length > 0) {\n        var startNeighbors = getNeighbors(grid, grid[$points.startNode.row][$points.startNode.col])\n        sctNodes.push(startNeighbors)\n        Object.entries(sctNodes).forEach(neighbors => {\n            console.log(neighbors)\n            neighbors[1].forEach(node => {\n                var nodeNeighbors = getNeighbors(grid, node)\n                sctNodes.push(nodeNeighbors)\n            })\n        }) \n   } \n   console.log(sctNodes)\n}\n\n\n//function to get neighbors by node\nfunction getNeighbors(grid, node) {\n    var nodeNeighbors = []\n    if(node !== undefined || null) {\n        nodeNeighbors.push(grid[node.row][node.col+1])\n        //nodeNeighbors.nodeRight.isVisited = true\n        nodeNeighbors.push(grid[node.row][node.col-1])\n        //nodeNeighbors.nodeLeft.isVisited = true\n        nodeNeighbors.push(grid[node.row-1][node.col])\n        //nodeNeighbors.nodeUp.isVisited = true\n        nodeNeighbors.push(grid[node.row+1][node.col])\n        //nodeNeighbors.nodeDown.isVisited = true\n\n    }\n    return nodeNeighbors\n}\n\n  \n // a visited node will never be checked again\n // function to update nodes to visited\n\n//function to sort shortest nodes \n/*\nfunction sortShortest(grid) {\n\n}\n*/\n\nfunction getPoints(node) {\n    if(node.startNode) {\n        $points.startNode = node\n    }\n    else if(node.endNode) {\n        $points.endNode = node\n    }\n    return $points\n}\n\nfunction getNodes(grid) {\n    const nodes = []\n    for (let row of grid) {\n        const currRow = []\n        for(var node of row) {\n            if(node.startNode) {\n                node.nodeDistance = 0\n                $points.startNode = node\n            }\n            else if(node.endNode) {\n                $points.endNode = node\n            }\n            currRow.push(node)\n        }\n        nodes.push(currRow)\n    }\n    console.log($points)\n    return nodes \n}\n\nexport default Dijkstra"]},"metadata":{},"sourceType":"module"}