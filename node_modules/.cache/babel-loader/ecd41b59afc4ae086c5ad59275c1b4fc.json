{"ast":null,"code":"const $points = {};\nexport default function Dijkstra(grid) {\n  //const nodes = getNodes(grid)\n  const unvisitedNodes = getNodes(grid);\n  console.log('grid, nodes, $points', grid, unvisitedNodes, $points);\n  var sctNodes = [];\n  var distanceCounter = 0;\n\n  if (!!Object.keys($points).length) {\n    var startNeighbors = getNeighbors(grid, grid[$points.startNode.row][$points.startNode.col]);\n    startNeighbors.forEach(node => sctNodes.push(node));\n    const foo = sortDistance(unvisitedNodes);\n    console.log(nodes, foo);\n    /*while(!!unvisitedNodes.length) { \n        const nextNode = unvisitedNodes.shift()\n        console.log(nextNode)\n    }  */\n  }\n\n  console.log('sctNodes', sctNodes);\n}\n\nfunction sortDistance(unvisited) {\n  unvisited.sort((a, b) => a.distance - b.distance);\n} //function to get neighbors by node\n\n\nfunction getNeighbors(grid, node) {\n  var nodeNeighbors = [];\n\n  if (node !== undefined || null) {\n    nodeNeighbors.push(grid[node.row][node.col + 1]); //nodeNeighbors.nodeRight.isVisited = true\n\n    nodeNeighbors.push(grid[node.row][node.col - 1]); //nodeNeighbors.nodeLeft.isVisited = true\n\n    nodeNeighbors.push(grid[node.row - 1][node.col]); //nodeNeighbors.nodeUp.isVisited = true\n\n    nodeNeighbors.push(grid[node.row + 1][node.col]); //nodeNeighbors.nodeDown.isVisited = true\n  }\n\n  return nodeNeighbors;\n} // a visited node will never be checked again\n// function to update nodes to visited\n//function to sort shortest nodes \n\n/*\nfunction sortShortest(grid) {\n\n}\n*/\n\n\nfunction getPoints(node) {\n  if (node.startNode) {\n    $points.startNode = node;\n  } else if (node.endNode) {\n    $points.endNode = node;\n  }\n\n  return $points;\n}\n/*\nfunction getNodes(grid) {\n    const nodes = []\n    for (let row of grid) {\n        const currRow = []\n        for(var node of row) {\n            if(node.startNode) {\n                node.nodeDistance = 0\n                $points.startNode = node\n            }\n            else if(node.endNode) {\n                $points.endNode = node\n            }\n            currRow.push(node)\n        }\n        nodes.push(currRow)\n    }\n    console.log($points)\n    return nodes \n}\n*/\n\n\nfunction getNodes(grid) {\n  const nodes = [];\n\n  for (const row of grid) {\n    for (const node of row) {\n      if (node.startNode) {\n        $points.startNode = node;\n      } else if (node.endNode) {\n        $points.endNode = node;\n      }\n\n      nodes.push(node);\n    }\n  }\n\n  return nodes;\n}","map":{"version":3,"sources":["/Users/sm00th-swagger/fun/pathfinderjs/src/dijkstras.js"],"names":["$points","Dijkstra","grid","unvisitedNodes","getNodes","console","log","sctNodes","distanceCounter","Object","keys","length","startNeighbors","getNeighbors","startNode","row","col","forEach","node","push","foo","sortDistance","nodes","unvisited","sort","a","b","distance","nodeNeighbors","undefined","getPoints","endNode"],"mappings":"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","sourcesContent":["\nconst $points = {}\n\nexport default function Dijkstra(grid) {\n    //const nodes = getNodes(grid)\n    const unvisitedNodes = getNodes(grid)\n    console.log('grid, nodes, $points', grid, unvisitedNodes, $points)\n    var sctNodes = []\n    var distanceCounter = 0\n    if(!!Object.keys($points).length) {\n        var startNeighbors = getNeighbors(grid, grid[$points.startNode.row][$points.startNode.col])\n        startNeighbors.forEach(node => sctNodes.push(node)) \n        const foo = sortDistance(unvisitedNodes)\n        console.log(nodes, foo)\n        /*while(!!unvisitedNodes.length) { \n            const nextNode = unvisitedNodes.shift()\n            console.log(nextNode)\n        }  */\n    } \n   console.log('sctNodes', sctNodes)\n}\n\nfunction sortDistance(unvisited) {\n    unvisited.sort((a, b) => a.distance - b.distance)\n}\n\n\n//function to get neighbors by node\nfunction getNeighbors(grid, node) {\n    var nodeNeighbors = []\n    if(node !== undefined || null) {\n        nodeNeighbors.push(grid[node.row][node.col+1])\n        //nodeNeighbors.nodeRight.isVisited = true\n        nodeNeighbors.push(grid[node.row][node.col-1])\n        //nodeNeighbors.nodeLeft.isVisited = true\n        nodeNeighbors.push(grid[node.row-1][node.col])\n        //nodeNeighbors.nodeUp.isVisited = true\n        nodeNeighbors.push(grid[node.row+1][node.col])\n        //nodeNeighbors.nodeDown.isVisited = true\n\n    }\n    return nodeNeighbors\n}\n\n  \n // a visited node will never be checked again\n // function to update nodes to visited\n\n//function to sort shortest nodes \n/*\nfunction sortShortest(grid) {\n\n}\n*/\n\nfunction getPoints(node) {\n    if(node.startNode) {\n        $points.startNode = node\n    }\n    else if(node.endNode) {\n        $points.endNode = node\n    }\n    return $points\n}\n\n/*\nfunction getNodes(grid) {\n    const nodes = []\n    for (let row of grid) {\n        const currRow = []\n        for(var node of row) {\n            if(node.startNode) {\n                node.nodeDistance = 0\n                $points.startNode = node\n            }\n            else if(node.endNode) {\n                $points.endNode = node\n            }\n            currRow.push(node)\n        }\n        nodes.push(currRow)\n    }\n    console.log($points)\n    return nodes \n}\n*/\n\nfunction getNodes(grid) {\n    const nodes = [];\n    for (const row of grid) {\n      for (const node of row) {\n        if(node.startNode) {\n            $points.startNode = node\n        }\n        else if(node.endNode) {\n            $points.endNode = node\n        }\n        nodes.push(node)\n      }\n    }\n    return nodes;\n}\n\n"]},"metadata":{},"sourceType":"module"}