{"ast":null,"code":"const $points = {};\nexport default function Dijkstra(grid) {\n  //const nodes = getNodes(grid)\n  const unvisitedNodes = getNodes(grid);\n  const visitedNodes = []; //console.log('foobar', grid, unvisitedNodes, visitedNodes)\n\n  if (!!Object.keys($points).length) {\n    //var startNeighbors = getNeighbors(grid, grid[$points.startNode.row][$points.startNode.col])\n    //startNeighbors.forEach(node => sctNodes.push(node)) \n    while (!!unvisitedNodes.length) {\n      sortDistance(unvisitedNodes);\n      const currentNode = unvisitedNodes.shift();\n      updateNodes(grid, currentNode);\n    }\n  } //console.log('sctNodes', visitedNodes)\n\n}\n\nfunction sortDistance(unvisited) {\n  unvisited.sort((a, b) => a.nodeDistance - b.nodeDistance);\n}\n\nfunction updateNodes(grid, node) {\n  const neighbors = getNeighbors(grid, node);\n  neighbors.forEach(node => {\n    if (node.nodeDistance == Infinity) node.nodeDistance = node.previousNode.nodeDistance + 1;\n  });\n} //function to get neighbors by node -- sets previousNode\n\n\nfunction getNeighbors(grid, node) {\n  // update distance \n  var nodeNeighbors = [];\n\n  if (node) {\n    try {\n      if (grid[node.row][node.col + 1] != undefined || null) {\n        //console.log(grid[node.row][node.col+1])\n        grid[node.row][node.col + 1].previousNode = node;\n        nodeNeighbors.push(grid[node.row][node.col + 1]);\n      }\n\n      if (grid[node.row][node.col - 1] != undefined || null) {\n        //console.log(grid[node.row][node.col-1])\n        grid[node.row][node.col - 1].previousNode = node;\n        nodeNeighbors.push(grid[node.row][node.col - 1]);\n      }\n\n      if (grid[node.row + 1][node.col] != undefined || null) {\n        //console.log(grid[node.row+1][node.col])\n        grid[node.row + 1][node.col].previousNode = node;\n        nodeNeighbors.push(grid[node.row + 1][node.col]);\n      }\n\n      if (grid[node.row - 1][node.col] != undefined || null) {\n        //console.log(grid[node.row-1][node.col])\n        grid[node.row - 1][node.col].previousNode = node;\n        nodeNeighbors.push(grid[node.row - 1][node.col]);\n      }\n    } finally {\n      return nodeNeighbors;\n    }\n  } //return nodeNeighbors\n\n}\n\nfunction getPoints(node) {\n  if (node.startNode) {\n    $points.startNode = node;\n  } else if (node.endNode) {\n    $points.endNode = node;\n  }\n\n  return $points;\n}\n\nfunction getNodes(grid) {\n  const nodes = [];\n\n  for (const row of grid) {\n    for (const node of row) {\n      if (node.startNode) {\n        $points.startNode = node;\n        node.nodeDistance = 0;\n        node.startNode = true;\n      } else if (node.endNode) {\n        $points.endNode = node;\n      }\n\n      nodes.push(node);\n    }\n  }\n\n  return nodes;\n}","map":{"version":3,"sources":["/Users/sm00th-swagger/fun/pathfinderjs/src/dijkstras.js"],"names":["$points","Dijkstra","grid","unvisitedNodes","getNodes","visitedNodes","Object","keys","length","sortDistance","currentNode","shift","updateNodes","unvisited","sort","a","b","nodeDistance","node","neighbors","getNeighbors","forEach","Infinity","previousNode","nodeNeighbors","row","col","undefined","push","getPoints","startNode","endNode","nodes"],"mappings":"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","sourcesContent":["\nconst $points = {}\n\nexport default function Dijkstra(grid) {\n    //const nodes = getNodes(grid)\n    const unvisitedNodes = getNodes(grid)\n    const visitedNodes = []\n    //console.log('foobar', grid, unvisitedNodes, visitedNodes)\n    if(!!Object.keys($points).length) {\n        //var startNeighbors = getNeighbors(grid, grid[$points.startNode.row][$points.startNode.col])\n        //startNeighbors.forEach(node => sctNodes.push(node)) \n        while(!!unvisitedNodes.length) { \n            sortDistance(unvisitedNodes)\n            const currentNode = unvisitedNodes.shift()\n            updateNodes(grid, currentNode)\n        }\n    } \n    //console.log('sctNodes', visitedNodes)\n}\n\nfunction sortDistance(unvisited) {\n    unvisited.sort((a, b) => a.nodeDistance - b.nodeDistance)\n}\n\n\nfunction updateNodes(grid, node) {\n    const neighbors = getNeighbors(grid, node)\n    neighbors.forEach(node => {\n        if(node.nodeDistance == Infinity) \n            node.nodeDistance = node.previousNode.nodeDistance + 1\n    })\n}\n\n//function to get neighbors by node -- sets previousNode\nfunction getNeighbors(grid, node) { // update distance \n    var nodeNeighbors = []\n    if(node) {\n        try {\n            if(grid[node.row][node.col+1] != undefined || null) {\n                //console.log(grid[node.row][node.col+1])\n                grid[node.row][node.col+1].previousNode = node\n                nodeNeighbors.push(grid[node.row][node.col+1])\n            }\n            if(grid[node.row][node.col-1] != undefined || null) {\n                //console.log(grid[node.row][node.col-1])\n                grid[node.row][node.col-1].previousNode = node\n                nodeNeighbors.push(grid[node.row][node.col-1])\n            }\n            if(grid[node.row+1][node.col] != undefined || null) {\n                //console.log(grid[node.row+1][node.col])\n                grid[node.row+1][node.col].previousNode = node\n                nodeNeighbors.push(grid[node.row+1][node.col])\n            }\n            if(grid[node.row-1][node.col] != undefined || null) {\n                //console.log(grid[node.row-1][node.col])\n                grid[node.row-1][node.col].previousNode = node\n                nodeNeighbors.push(grid[node.row-1][node.col])\n            }\n        }\n        finally {\n            return nodeNeighbors\n        }\n    }\n    //return nodeNeighbors\n}\n\n\nfunction getPoints(node) {\n    if(node.startNode) {\n        $points.startNode = node\n    }\n    else if(node.endNode) {\n        $points.endNode = node\n    }\n    return $points\n}\n\n\nfunction getNodes(grid) {\n    const nodes = [];\n    for (const row of grid) {\n      for (const node of row) {\n        if(node.startNode) {\n            $points.startNode = node\n            node.nodeDistance = 0\n            node.startNode = true\n        }\n        else if(node.endNode) {\n            $points.endNode = node\n        }\n        nodes.push(node)\n      }\n    }\n    return nodes;\n}\n\n"]},"metadata":{},"sourceType":"module"}