{"ast":null,"code":"const $points = {};\nexport default function Dijkstra(grid) {\n  //const nodes = getNodes(grid)\n  const unvisitedNodes = getNodes(grid);\n  visitedNodes = [];\n\n  if (!!Object.keys($points).length) {\n    //var startNeighbors = getNeighbors(grid, grid[$points.startNode.row][$points.startNode.col])\n    //startNeighbors.forEach(node => sctNodes.push(node)) \n    while (!!unvisitedNodes.length) {\n      const currentNode = unvisitedNodes.shift();\n      console.log(currentNode);\n    }\n  }\n\n  console.log('sctNodes', visitedNodes);\n}\n\nfunction sortDistance(unvisited) {\n  return unvisited.sort((a, b) => a.distance - b.distance);\n} //function to get neighbors by node\n\n\nfunction getNeighbors(grid, node) {\n  var nodeNeighbors = [];\n\n  if (node !== undefined || null) {\n    nodeNeighbors.push(grid[node.row][node.col + 1]);\n    nodeNeighbors.push(grid[node.row][node.col - 1]);\n    nodeNeighbors.push(grid[node.row - 1][node.col]);\n    nodeNeighbors.push(grid[node.row + 1][node.col]);\n  }\n\n  return nodeNeighbors;\n}\n\nfunction getPoints(node) {\n  if (node.startNode) {\n    $points.startNode = node;\n  } else if (node.endNode) {\n    $points.endNode = node;\n  }\n\n  return $points;\n}\n\nfunction getNodes(grid) {\n  const nodes = [];\n\n  for (const row of grid) {\n    for (const node of row) {\n      if (node.startNode) {\n        $points.startNode = node;\n      } else if (node.endNode) {\n        $points.endNode = node;\n      }\n\n      nodes.push(node);\n    }\n  }\n\n  return nodes;\n}","map":{"version":3,"sources":["/Users/sm00th-swagger/fun/pathfinderjs/src/dijkstras.js"],"names":["$points","Dijkstra","grid","unvisitedNodes","getNodes","visitedNodes","Object","keys","length","currentNode","shift","console","log","sortDistance","unvisited","sort","a","b","distance","getNeighbors","node","nodeNeighbors","undefined","push","row","col","getPoints","startNode","endNode","nodes"],"mappings":"AACA,MAAMA,OAAO,GAAG,EAAhB;AAEA,eAAe,SAASC,QAAT,CAAkBC,IAAlB,EAAwB;AACnC;AACA,QAAMC,cAAc,GAAGC,QAAQ,CAACF,IAAD,CAA/B;AACAG,EAAAA,YAAY,GAAG,EAAf;;AACA,MAAG,CAAC,CAACC,MAAM,CAACC,IAAP,CAAYP,OAAZ,EAAqBQ,MAA1B,EAAkC;AAC9B;AACA;AACA,WAAM,CAAC,CAACL,cAAc,CAACK,MAAvB,EAA+B;AAC3B,YAAMC,WAAW,GAAGN,cAAc,CAACO,KAAf,EAApB;AACAC,MAAAA,OAAO,CAACC,GAAR,CAAYH,WAAZ;AACH;AACJ;;AACFE,EAAAA,OAAO,CAACC,GAAR,CAAY,UAAZ,EAAwBP,YAAxB;AACF;;AAED,SAASQ,YAAT,CAAsBC,SAAtB,EAAiC;AAC7B,SAAOA,SAAS,CAACC,IAAV,CAAe,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,CAACE,QAAF,GAAaD,CAAC,CAACC,QAAxC,CAAP;AACH,C,CAGD;;;AACA,SAASC,YAAT,CAAsBjB,IAAtB,EAA4BkB,IAA5B,EAAkC;AAC9B,MAAIC,aAAa,GAAG,EAApB;;AACA,MAAGD,IAAI,KAAKE,SAAT,IAAsB,IAAzB,EAA+B;AAC3BD,IAAAA,aAAa,CAACE,IAAd,CAAmBrB,IAAI,CAACkB,IAAI,CAACI,GAAN,CAAJ,CAAeJ,IAAI,CAACK,GAAL,GAAS,CAAxB,CAAnB;AACAJ,IAAAA,aAAa,CAACE,IAAd,CAAmBrB,IAAI,CAACkB,IAAI,CAACI,GAAN,CAAJ,CAAeJ,IAAI,CAACK,GAAL,GAAS,CAAxB,CAAnB;AACAJ,IAAAA,aAAa,CAACE,IAAd,CAAmBrB,IAAI,CAACkB,IAAI,CAACI,GAAL,GAAS,CAAV,CAAJ,CAAiBJ,IAAI,CAACK,GAAtB,CAAnB;AACAJ,IAAAA,aAAa,CAACE,IAAd,CAAmBrB,IAAI,CAACkB,IAAI,CAACI,GAAL,GAAS,CAAV,CAAJ,CAAiBJ,IAAI,CAACK,GAAtB,CAAnB;AAEH;;AACD,SAAOJ,aAAP;AACH;;AAGD,SAASK,SAAT,CAAmBN,IAAnB,EAAyB;AACrB,MAAGA,IAAI,CAACO,SAAR,EAAmB;AACf3B,IAAAA,OAAO,CAAC2B,SAAR,GAAoBP,IAApB;AACH,GAFD,MAGK,IAAGA,IAAI,CAACQ,OAAR,EAAiB;AAClB5B,IAAAA,OAAO,CAAC4B,OAAR,GAAkBR,IAAlB;AACH;;AACD,SAAOpB,OAAP;AACH;;AAGD,SAASI,QAAT,CAAkBF,IAAlB,EAAwB;AACpB,QAAM2B,KAAK,GAAG,EAAd;;AACA,OAAK,MAAML,GAAX,IAAkBtB,IAAlB,EAAwB;AACtB,SAAK,MAAMkB,IAAX,IAAmBI,GAAnB,EAAwB;AACtB,UAAGJ,IAAI,CAACO,SAAR,EAAmB;AACf3B,QAAAA,OAAO,CAAC2B,SAAR,GAAoBP,IAApB;AACH,OAFD,MAGK,IAAGA,IAAI,CAACQ,OAAR,EAAiB;AAClB5B,QAAAA,OAAO,CAAC4B,OAAR,GAAkBR,IAAlB;AACH;;AACDS,MAAAA,KAAK,CAACN,IAAN,CAAWH,IAAX;AACD;AACF;;AACD,SAAOS,KAAP;AACH","sourcesContent":["\nconst $points = {}\n\nexport default function Dijkstra(grid) {\n    //const nodes = getNodes(grid)\n    const unvisitedNodes = getNodes(grid)\n    visitedNodes = []\n    if(!!Object.keys($points).length) {\n        //var startNeighbors = getNeighbors(grid, grid[$points.startNode.row][$points.startNode.col])\n        //startNeighbors.forEach(node => sctNodes.push(node)) \n        while(!!unvisitedNodes.length) { \n            const currentNode = unvisitedNodes.shift()\n            console.log(currentNode)\n        } \n    } \n   console.log('sctNodes', visitedNodes)\n}\n\nfunction sortDistance(unvisited) {\n    return unvisited.sort((a, b) => a.distance - b.distance)\n}\n\n\n//function to get neighbors by node\nfunction getNeighbors(grid, node) {\n    var nodeNeighbors = []\n    if(node !== undefined || null) {\n        nodeNeighbors.push(grid[node.row][node.col+1])\n        nodeNeighbors.push(grid[node.row][node.col-1])\n        nodeNeighbors.push(grid[node.row-1][node.col])\n        nodeNeighbors.push(grid[node.row+1][node.col])\n\n    }\n    return nodeNeighbors\n}\n\n\nfunction getPoints(node) {\n    if(node.startNode) {\n        $points.startNode = node\n    }\n    else if(node.endNode) {\n        $points.endNode = node\n    }\n    return $points\n}\n\n\nfunction getNodes(grid) {\n    const nodes = [];\n    for (const row of grid) {\n      for (const node of row) {\n        if(node.startNode) {\n            $points.startNode = node\n        }\n        else if(node.endNode) {\n            $points.endNode = node\n        }\n        nodes.push(node)\n      }\n    }\n    return nodes;\n}\n\n"]},"metadata":{},"sourceType":"module"}